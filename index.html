<!DOCTYPE html>
<html>
	<head>
		<title>A nice little graphing calculator</title>
		<link rel="shortcut icon" href="https://lh6.googleusercontent.com/-eJP7CsCRims/AAAAAAAAAAI/AAAAAAAAAOE/9fdQHCWUWQs/s32-c-k-no/photo.jpg"/>
		<link rel="stylesheet" type="text/css" href="css/style.css">
		<meta charset="UTF-8">
	</head>

	<body>
		<input type="text" name="function" placeholder="y=" class="functionInput" id="function"></textarea>
		<!-- <input type="range" id="rotate" min="0" max="360" value ="360" step = "30" onchange="rotate()"/> -->
		<button type="button" onclick="submit()">Graph Me</button>
		<a>Make sure to type the function in a programming format, for example, 2x+3 is <b>2*x+3</b>, and sin(2x) is <b>Math.sin(2*x)</b>. \u222b I was too lazy to change it. Also sometimes a black line may appear when you are trying to rotate the solid, I'll fix that problem later.</a>
		<form id="quality">
    		<p>
        		<label>Quality Select</label>
        			<input type = "radio"
                		name = "quality"
                		id = "poor"
                		value = "1" />
        		<label for = "fast">fast</label>

        		<input type = "radio"
            		name = "quality"
                	id = "medium"
                	value = "0.5"
					checked = "checked" />
        		<label for = "medium">medium</label>

        		<input type = "radio"
                	name = "quality"
                	id = "good"
                	value = "0.25" />
    			<label for = "good">good</label>

				<input type = "radio"
					name = "quality"
					id = "godlike"
					value = "0.1" />
				<label for = "godlike">How much did you pay for your computer???</label>

				<input type = "radio"
				name = "quality"
				id = "off"
				value = "0" />
				<label for = "off">off</label>
        	</p>
    	</form>
		<canvas id="canvas"></canvas>

		<script src="js/three.min.js"></script>
		<script src="js/TrackballControls.js"></script>
		<script src="js/CanvasInput.js"></script>
		<script>
		var camera, controls, scene, renderer;
		var theFunctionValue;
		//The array will be used for future purposes
		var functionArray;
		function submit(){
			clearGraph();
			//Being lazy for now, I'll change this later. Using eval()
			var box = document.getElementById("function");
			theFunctionValue = box.value.replace(/ /g,'');
			functionArray = theFunctionValue.split(/\+?("[^"]*"|[^\s+])+/g);
			//Graph
			var quality = qualitySelect([document.getElementById('poor'),document.getElementById('medium'),document.getElementById('good'),document.getElementById('godlike')]);
			var func = new Graph(theFunctionValue, 28,0.01);
			func.draw();
			func.drawShape(2*Math.PI, quality);
		}
		init();
		animate();
		function init(){
			var canvas = document.getElementById("canvas");
			camera = new THREE.PerspectiveCamera(45, window.innerWidth/ window.innerHeight, 1, 1000);
			camera.position.z = 5;
			camera.position.y = 50;
			camera.position.x = 0;
			renderer = new THREE.WebGLRenderer({canvas: canvas});
			renderer.setSize(window.innerWidth, window.innerHeight)
			document.body.appendChild(renderer.domElement);
			//The second parameter is the container.
			controls = new THREE.TrackballControls( camera, canvas);
			controls.addEventListener('change', render);
			scene = new THREE.Scene();
			var size = 28, step = 1;
			var geometry = new THREE.Geometry();
			geometry.verticesNeedUpdate = true;
			geometry.dynamic = true;
			var axes = new THREE.Geometry();
			axes.verticesNeedUpdate = true;
			axes.dynamic = true;
			var material = new THREE.LineBasicMaterial({color: "green"});
			var axismaterial = new THREE.LineBasicMaterial({color: "red"});
			for (var i = -size; i <= size; i += step){
				if(i == 0){
					axes.vertices.push(new THREE.Vector3(-size, -0.04, i));
					axes.vertices.push(new THREE.Vector3(size, -0.04, i));
					axes.vertices.push(new THREE.Vector3(i, -0.04, -size));
					axes.vertices.push(new THREE.Vector3(i, -0.04, size));
				} else {
					geometry.vertices.push(new THREE.Vector3(-size, -0.04, i));
					geometry.vertices.push(new THREE.Vector3(size, -0.04, i));
					geometry.vertices.push(new THREE.Vector3(i, -0.04, -size));
					geometry.vertices.push(new THREE.Vector3(i, -0.04, size));
				}
			}
				var line = new THREE.Line(geometry, material, THREE.LinePieces);
				var lineaxes = new THREE.Line(axes, axismaterial, THREE.LinePieces);
				scene.add(line);
				scene.add(lineaxes);
				hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.6 );
				hemiLight.color.setHSL( 0.6, 1, 0.6 );
				hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
				hemiLight.position.set( 0, 500, 0 );
				scene.add( hemiLight );

				var light1 = new THREE.PointLight( 0xffff00, 1, 5000 );
				light1.position.set( 0, 100, 90 );
				scene.add( light1 );

				render();
			}

		function Graph(given, graphSize, step){
			var func;
			this.given = given;
			this.graphSize = graphSize;
			this.step = step;
			this.func = func;
		}

		Graph.prototype.draw = function(){
			var x = -(this.graphSize);
			var points = [];
			//I'll change this later, just using a counter variable for now
			var counter = -(this.graphSize);
			for (var i = -(this.graphSize); i <= this.graphSize; i+= this.step){
			//Somehow the plane is "backwards", the positive y-cordinate is negative
				if(this.given!=null){
					this.func = -(eval(this.given));
				}
				points[counter+this.graphSize] = new THREE.Vector3(x.toFixed(2),0,this.func);
				x+=this.step;
				counter++;
			}
			var spline = new THREE.SplineCurve3(points);
			var geometry = new THREE.Geometry();
			geometry.verticesNeedUpdate = true;
			geometry.dynamic = true;
			var splinePoints = spline.getPoints(points.length-1);
			var material = new THREE.LineBasicMaterial( { color: "white" } );
			for(var i = 0; i < splinePoints.length; i++){
				if(Math.abs((spline.points[i]).z)<=this.graphSize){
					geometry.vertices.push(spline.points[i]);
				}
			}
			var graph = new THREE.Line(geometry, material);
			graph.name = "graph";
			scene.add(graph);
			render();
		}

		Graph.prototype.getY = function(xCord){
			var x = xCord;
			return eval(this.given);
		}

		Graph.prototype.drawShape = function(degree, value){
			var quality = Number(value);
			var group = new THREE.Object3D();
			group.name="solid";
			for(var i = 0; i < this.graphSize; i+=quality){
				if(this.getY(i) <= this.graphSize){
					var geometry = new THREE.CylinderGeometry(this.getY(i), this.getY(i+quality), quality, 100);
					geometry.verticesNeedUpdate = true;
					geometry.dynamic = true;
					geometry.applyMatrix(new THREE.Matrix4().makeTranslation(0,-(i+quality/2), 0));
					var material =new THREE.MeshPhongMaterial( { color: 0xffff00, shading: THREE.SmoothShading });
					var plane = new THREE.Mesh( geometry, material );
					plane.material.color.setHex(0xffff00);
					plane.rotation.set(0,0,Math.PI/2);
					plane.overdraw = true;
					group.add(plane);
					//
				}
			}
			scene.add(group);
			render();
		}

		//I want it to be a prototype function, but this will do the trick for now. I know it's messy
		function rotate(){
			var bar = document.getElementById("rotate");
			var value = bar.value;
			clearGraph();
			var graph = new Graph(theFunctionValue, 14, 0.01);
			graph.drawShape(value * (Math.PI/180));
			render();
		}

		function clearGraph(){
			for(var i = scene.children.length; i>=0; i--){
				if(scene.children[i] != null){
					if(scene.children[i].name == "graph" || scene.children[i].name == "solid"){
						scene.remove(scene.children[i]);
					}
				}
			}
		}

		function qualitySelect(array){
			for(var i = 0; i < array.length; i++){
				if(array[i].checked){
					return array[i].value;
				}
			}
		}

		function animate(){
			requestAnimationFrame( animate );
			controls.update();
		}

		function render(){
			renderer.render( scene, camera );
		}
		</script>
	</body>
</html>
