<!DOCTYPE html>
<html>
	<head>
		<title>A solids of revolution graphing calculator</title>
		<link rel="shortcut icon" href="https://lh6.googleusercontent.com/-eJP7CsCRims/AAAAAAAAAAI/AAAAAAAAAOE/9fdQHCWUWQs/s32-c-k-no/photo.jpg"/>
		<link rel="stylesheet" type="text/css" href="css/style.css">
		<meta charset="UTF-8">
	</head>

	<body>
		<input type="text" name="function" placeholder="y=" class="functionInput" onchange="submit()" id="function">
		<button type="button" onclick="submit()">Graph Me</button>
		<input type="text" name="bounds" placeholder="x=0" class="functionInput" id="bound1">
		<input type="text" name="bounds" placeholder="x=28" class="functionInput" id="bound2">
		<!-- <input type="range" id="rotate" min="0" max="360" value ="360" step = "30" onchange="rotate()"/> -->


		<a>Make sure to type the function in a programming format, for example, 2x+3 is <b>2*x+3</b>, and sin(2x) is <b>Math.sin(2*x)</b>. The graph is bounded by x=0, y=0 by default, and it's being rotated around y=0 by default.</a>
    	<p>Select graphing quality:</p>

		<select id="quality" onchange="updateQuality()">
			<option value="1">Low
			<option value="0.5">Medium
			<option value="0.25">High
			<option value="0.1">Ultra
		</select>

		<canvas id="canvas"></canvas>

		<script src="js/three.min.js"></script>
		<script src="js/TrackballControls.js"></script>
		<script src="js/CanvasInput.js"></script>
		<script>
			var camera, controls, scene, renderer;
			var theFunctionValue;
			var bound1, bound2;
			var size = 28;
			init();
			animate();

			function init(){
				camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 1, 1000);
				camera.position.z = 5;
				camera.position.y = 50;
				camera.position.x = 0;

				var canvas = document.getElementById("canvas");
				renderer = new THREE.WebGLRenderer({canvas: canvas});
				renderer.setSize(window.innerWidth, window.innerHeight)
				document.body.appendChild(renderer.domElement);

				//The second parameter is the container.
				controls = new THREE.TrackballControls( camera, canvas);
				controls.addEventListener('change', render);

				addAxis();
				addLights();
				render();
			}

			function Graph(given){
				var func;
				this.given = given;
				this.func = func;
			}

			Graph.prototype.draw = function(){
				var x = -size;
				var points = [];
				var counter = x;  //I'll change this later, just using a counter variable for now
				var step = 0.01
				for (var i = -size; i <= size; i+= step){
					if(this.given!=null){
						this.func = -(eval(this.given));  //Somehow the plane is upside-down: the positive y-cordinate is negative
					}

					points[counter+size] = new THREE.Vector3(x.toFixed(2), 0, this.func);
					x+=step;
					counter++;
				}

				var geometry = new THREE.Geometry();
				geometry.verticesNeedUpdate = true;
				geometry.dynamic = true;

				var spline = new THREE.SplineCurve3(points);
				var splinePoints = spline.getPoints(points.length-1);

				for(var i = 0; i < splinePoints.length; i++){
					if(Math.abs((spline.points[i]).z) <= size){
						geometry.vertices.push(spline.points[i]);
					}
				}

				var material = new THREE.LineBasicMaterial({color: "white"});
				var graph = new THREE.Line(geometry, material);

				graph.name = "graph";
				scene.add(graph);
				render();
			}

			Graph.prototype.getY = function(xCoord){
				var x = xCoord;
				return eval(this.given);
			}

			Graph.prototype.drawShape = function(value, bound1, bound2){  //Degree is unused
				var quality = Number(value);
				var group = new THREE.Object3D();
				group.name="solid";
				for(var i = bound1; i < bound2; i+=quality){
					if(this.getY(i) <= size){
						var geometry = new THREE.CylinderGeometry(this.getY(i), this.getY(i+quality), quality, 100);
						geometry.verticesNeedUpdate = true;
						geometry.dynamic = true;
						geometry.applyMatrix(new THREE.Matrix4().makeTranslation(0,-(i+quality/2), 0));

						var material =new THREE.MeshPhongMaterial({color: 0xffff00, shading: THREE.SmoothShading, transparent: true, opacity: 0.75});
						var plane = new THREE.Mesh(geometry, material);
						plane.material.color.setHex(0xffff00);
						plane.rotation.set(0,0,Math.PI/2);
						plane.overdraw = true;
						group.add(plane);
					}
				}
				scene.add(group);
				render();
			}

			function clearGraph(){
				for(var i = scene.children.length; i>=0; i--){
					if(scene.children[i] != null){
						if(scene.children[i].name == "graph" || scene.children[i].name == "solid"){
							scene.remove(scene.children[i]);
						}
					}
				}
			}

			function submit(){
				clearGraph();
				//Being lazy for now, I'll change this later. Using eval()
				var box = document.getElementById("function");
				theFunctionValue = box.value.replace(/ /g,'');
				functionArray = theFunctionValue.split(/\+?("[^"]*"|[^\s+])+/g);
				//Graph
				var quality = document.getElementById("quality").value;
				var func = new Graph(theFunctionValue);
				func.draw();
				console.log(document.getElementById("bound1").value);
				if(document.getElementById("bound1").value!="" && document.getElementById("bound2").value!=""){
					func.drawShape(quality,Number(document.getElementById("bound1").value), Number(document.getElementById("bound2").value));
				} else {
					func.drawShape(quality,0,size);
				}
			}

			function updateQuality(){
				clearGraph();
				var quality = document.getElementById("quality").value;
				var func = new Graph(document.getElementById("function").value, 28, 0.01);
				func.draw();
				func.drawShape(2*Math.PI, quality);
			}

			function animate(){
				requestAnimationFrame(animate);
				controls.update();
			}

			function render(){
				renderer.render(scene, camera);
			}

			function addLights(){
				hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.6);
				hemiLight.color.setHSL(0.6, 1, 0.6);
				hemiLight.groundColor.setHSL(0.095, 1, 0.75);
				hemiLight.position.set(0, 500, 0);
				scene.add(hemiLight);

				var light1 = new THREE.PointLight(0xffff00, 1, 5000);
				light1.position.set(0, 100, 90);
				scene.add(light1);
			}

			function addAxis(){
				var geometry = new THREE.Geometry();
				geometry.verticesNeedUpdate = true;
				geometry.dynamic = true;

				var axes = new THREE.Geometry();
				axes.verticesNeedUpdate = true;
				axes.dynamic = true;

				var step = 1;
				for(var i = -size; i <= size; i += step){
					if(i == 0){
						axes.vertices.push(new THREE.Vector3(-size, -0.04, i));
						axes.vertices.push(new THREE.Vector3(size, -0.04, i));
						axes.vertices.push(new THREE.Vector3(i, -0.04, -size));
						axes.vertices.push(new THREE.Vector3(i, -0.04, size));
					} else {
						geometry.vertices.push(new THREE.Vector3(-size, -0.04, i));
						geometry.vertices.push(new THREE.Vector3(size, -0.04, i));
						geometry.vertices.push(new THREE.Vector3(i, -0.04, -size));
						geometry.vertices.push(new THREE.Vector3(i, -0.04, size));
					}
				}

				var material = new THREE.LineBasicMaterial({color: "green"});
				var axismaterial = new THREE.LineBasicMaterial({color: "red"});
				var line = new THREE.Line(geometry, material, THREE.LinePieces);
				var lineaxes = new THREE.Line(axes, axismaterial, THREE.LinePieces);

				scene = new THREE.Scene();
				scene.add(line);
				scene.add(lineaxes);
			}
		</script>
	</body>
</html>
